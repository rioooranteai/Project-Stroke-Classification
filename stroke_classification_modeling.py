# -*- coding: utf-8 -*-
"""Stroke-Classification-Modeling.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AbtLrcWOWO8dnrxR43sgvs_v05yMRM4Q

# **Install & Import Modules**
"""

!pip install optuna catboost -q

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
import kagglehub
import os
import optuna

from catboost import CatBoostClassifier
from sklearn.impute import KNNImputer
from sklearn.model_selection import train_test_split, StratifiedKFold, cross_val_score
from sklearn.metrics import (
    classification_report, confusion_matrix, ConfusionMatrixDisplay,
    roc_auc_score, accuracy_score, precision_score, recall_score, f1_score, roc_curve
)
from scipy.stats.mstats import winsorize
from xgboost import XGBClassifier
from lightgbm import LGBMClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import DecisionTreeClassifier

warnings.filterwarnings('ignore')

"""# **Download Data**"""

path = kagglehub.dataset_download("fedesoriano/stroke-prediction-dataset")

print("Path to dataset files:", path)

"""# **Load Dataset**"""

full_path = os.path.join(path, "healthcare-dataset-stroke-data.csv")
df = pd.read_csv(full_path)

"""# **Data Preparation**"""

df_prep = df.copy()

"""## Drop Kolom yang Tidak Relevan (ID, Duplikat)"""

df_prep = df_prep.drop(columns=['id'])
df_prep = df_prep.drop_duplicates()

"""## Encoding Variabel Kategorikal"""

df_prep['gender'] = df_prep['gender'].apply(lambda x: 0 if x == 'Male' else 1 if x == "Female" else 2)
df_prep['ever_married'] = df_prep['ever_married'].apply(lambda x: 0 if x == 'Yes' else 1)
df_prep['Residence_type'] = df_prep['Residence_type'].apply(lambda x: 0 if x == 'Urban' else 1)

smoke_mapping = {
    'never smoked': 0,
    'formerly smoked': 1,
    'smokes': 2,
    'Unknown': 3
}
df_prep['smoking_status'] = df_prep['smoking_status'].map(smoke_mapping)
df_prep = pd.get_dummies(df_prep, columns=['work_type'], drop_first=True, prefix='work_type', dtype=int)

"""## Menangani Missing Values"""

imputer = KNNImputer(n_neighbors=5)
bmi_imputed = imputer.fit_transform(df_prep)
df_imputed = pd.DataFrame(bmi_imputed, columns=df_prep.columns)

"""## Menangani Outlier"""

con_columns = ['avg_glucose_level', 'bmi']
df_imputed[con_columns] = df_imputed[con_columns].apply(lambda x: winsorize(x, (0.05, 0.05)))

"""## Feature Engineering"""

df_imputed['age_group'] = pd.cut(
    df_imputed['age'],
    bins=[0, 30, 50, 100],
    labels=[0, 1, 2]
).astype(int)

df_imputed['glucose_bmi_interaction'] = (
    df_imputed['avg_glucose_level'] * df_imputed['bmi']
)
df_imputed['glucose_per_bmi'] = (
    df_imputed['avg_glucose_level'] / (df_imputed['bmi'] + 1e-3)
)

df_imputed['age_x_smoking'] = (
    df_imputed['age'] * df_imputed['smoking_status']
)

df_imputed['chronic_risk'] = (
    (df_imputed['hypertension'] == 1) &
    (df_imputed['heart_disease'] == 1)
).astype(int)

df_imputed['is_employed'] = (
    df_imputed['work_type_Private'] +
    df_imputed['work_type_Self-employed'] +
    df_imputed['work_type_Never_worked']
)

df_imputed['gender_hyper'] = (
    df_imputed['gender'] * df_imputed['hypertension']
)

"""## Split Data untuk Pelatihan dan Test

"""

X = df_imputed.drop(columns=['stroke'])
y = df_imputed['stroke']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)

"""# **Modeling**

## Model Selection
"""

models = {
    'RandomForest': RandomForestClassifier(random_state=42),
    'DecisionTree': DecisionTreeClassifier(random_state=42),
    'XGBoost': XGBClassifier(use_label_encoder=False, eval_metric='logloss', random_state=42),
    'LightGBM': LGBMClassifier(random_state=42, verbose=-1),
    'Catboost': CatBoostClassifier(verbose=0, random_state=42)
}

skf_non_umap = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)
model_scores_non_umap = {}

for name, model in models.items():
    scores = cross_val_score(model, X, y, cv=skf_non_umap, scoring='f1_macro')
    model_scores_non_umap[name] = np.mean(scores)
    print(f"{name}: F1-weighted Score = {model_scores_non_umap[name]:.4f}")

sorted_models_non_umap = sorted(model_scores_non_umap.items(), key=lambda x: x[1], reverse=True)

"""## Hyperparamter Tuning pada Model Catboost"""

def objective(trial):
    """
    Fungsi objektif untuk Optuna dengan DecisionTreeClassifier
    """
    params = {
        'criterion': trial.suggest_categorical('criterion', ['gini', 'entropy']),
        'max_depth': trial.suggest_int('max_depth', 2, 20),
        'min_samples_split': trial.suggest_int('min_samples_split', 2, 20),
        'min_samples_leaf': trial.suggest_int('min_samples_leaf', 1, 20),
        'max_features': trial.suggest_categorical('max_features', [None, 'sqrt', 'log2']),
        'random_state': 42,
    }

    model = DecisionTreeClassifier(**params)

    model.fit(X_train, y_train)

    y_pred = model.predict(X_test)
    f1 = f1_score(y_test, y_pred, average='macro')

    return f1

study = optuna.create_study(
        direction='maximize',
        sampler=optuna.samplers.TPESampler(seed=42),
        pruner=optuna.pruners.MedianPruner(n_startup_trials=10, n_warmup_steps=5)
    )

study.optimize(objective, n_trials=100, timeout=3600)

"""## Train Final Model"""

study.best_params

model_dt = DecisionTreeClassifier(**study.best_params, random_state=42)
model_dt.fit(X_train, y_train)

"""# **Evaluasi**"""

y_pred = model_dt.predict(X_test)
y_proba = model_dt.predict_proba(X_test)[:, 1]

"""## Classification Report"""

print(classification_report(y_test, y_pred, target_names=["Non-Stroke", "Stroke"]))

"""## Confusion Matrix"""

ConfusionMatrixDisplay.from_predictions(y_test, y_pred, display_labels=["Non-Stroke", "Stroke"])
plt.title("Confusion Matrix")
plt.show()

"""## Kurva ROC"""

fpr, tpr, _ = roc_curve(y_test, y_proba)

plt.figure(figsize=(6, 4))
plt.plot(fpr, tpr, label=f'ROC AUC = {roc_auc_score(y_test, y_proba):.2f}')
plt.plot([0, 1], [0, 1], linestyle='--', color='gray')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve - Decision Tree (Stroke Classification)')
plt.legend()
plt.grid()
plt.show()

